Standard for AI-Assisted Go Comment Management

Objective: To guide an AI in managing comments within Go code to enhance readability for humans (specifically new or mid-level software engineers) and AI, while ensuring documentation focuses on non-obvious logic and the "why" rather than the "what." The goal is to reduce comment clutter and improve code maintainability.

Core Principles:

    Readability First: Code should be written to be as self-documenting as possible. Comments are supplementary and should aid understanding, not compensate for obscure code.
    Document the "Why," Not the "What": Comments should explain the intent, design decisions, trade-offs, and reasons behind a particular implementation, especially if it's not immediately obvious. If the code clearly states what it's doing, a comment restating that is redundant.
    Target Audience: Assume comments are primarily for a new or mid-level software engineer who is familiar with Go but may not have deep context on the specific codebase or complex algorithms.
    Conciseness and Precision: Comments should be brief, to the point, and use clear language. Avoid jargon where simpler terms suffice.
    godoc Compliance: Adhere to Go's standard documentation practices for godoc to ensure comments are discoverable and well-formatted in generated documentation.

Instructions for the AI:

The AI should analyze comments based on the following categories and take the recommended actions:

I. Comments to REMOVE:

    A. Obvious "What" Comments:
        Rule: If a comment merely restates what a line or a small, clear block of Go code is doing, and this action is evident to a mid-level Go developer, the comment should be removed.
        Examples for Removal:
            // Initialize x to 10 x := 10
            // Increment counter counter++
            // Return the error return err
            // Loop through the slice for _, item := range items { ... }
    B. Version Control / Change Log Remnants:
        Rule: Comments that act as informal version control or change logs are redundant when a proper version control system (like Git) is in use.
        Examples for Removal:
            // MODIFIED: Named return error
            // Added by [Author Name] on [Date]
            // Bug fix for #123 (unless it points to a crucial understanding of a non-obvious fix, in which case rephrase to explain the why of the fix itself).
            // Old code: commentedOutFunction()
    C. Task/Ticket Trackers or Trivial Instructions:
        Rule: Comments referencing internal task IDs, simple instructional steps, or TODOs for trivial tasks that should be evident from the code or managed in an issue tracker. For non-trivial TODOs, see section II.C.
        Examples for Removal:
            // Task 2.3: Download the file using the RawURL
            // TODO: Refactor this later (if the "why" or "what" of the refactor isn't critical context for the current code's understanding).
            // Next, we process the input
    D. Commented-Out Code:
        Rule: Large blocks of commented-out code should generally be removed. Version control systems are the place to find old code. If a small snippet is commented out for a very temporary debugging purpose by the current developer, it might be an exception, but the AI should flag it for review or assume removal if the purpose isn't explicitly stated as temporary and critical.
    E. Noise Comments and "Divider" Comments:
        Rule: Comments that add no semantic value, such as excessive asterisks, "decorative" banners, or overly simplistic section dividers that don't aid in understanding the code's structure significantly more than good formatting and package organization.
        Examples for Removal:
            // *************************************
            // End of function
            // Helper functions (if the following functions are clearly helpers by their naming and scope).

II. Comments to RETAIN, REPHRASE, or PROMPT FOR:

    A. Explaining the "Why" - Intent and Design Decisions:
        Rule: Comments that explain why a particular approach was taken, especially if there were alternatives or if the logic seems counter-intuitive or complex. These often relate to business logic, performance optimizations, or workarounds for external system quirks.
        Action: Retain. If the "why" is unclear or mixed with "what," prompt the developer to rephrase for clarity, focusing on the rationale.
        Good Examples (to retain/encourage):
            // Using a channel here to prevent race conditions when multiple goroutines update the counter.
            // This custom sort is needed because the default sort doesn't handle Unicode characters in the desired order for this specific requirement.
            // We are intentionally ignoring this error here because the upstream API occasionally returns spurious errors that don't affect functionality, and retrying has proven ineffective. See [link to issue/docs].
            // This timeout is set to 500ms based on performance testing; lower values caused too many false positives.
    B. Documenting Non-Obvious Logic or Complex Algorithms:
        Rule: If the code implements a complex algorithm, intricate state management, or logic that isn't immediately apparent from reading the code itself, comments are essential. These should provide a high-level overview or clarify tricky parts.
        Action: Retain. If the explanation is insufficient or too focused on the "what," prompt for a clearer explanation of the complexity or the non-obvious aspects.
        Good Examples (to retain/encourage):
            // This function implements the A* search algorithm to find the optimal path. The heuristic used is Manhattan distance.
            // The state machine transitions are handled here. Be careful when adding new states to update all relevant transitions.
            // This bitwise operation is a performance optimization for checking powers of two.
    C. Important TODO or FIXME Comments:
        Rule: Comments like // TODO: or // FIXME: that highlight significant issues, pending work that impacts current functionality, or security concerns. These should ideally explain the implication of the TODO/FIXME.
        Action: Retain. If the comment lacks context (e.g., // TODO: Fix this), prompt the developer to add details about what needs fixing, why it's an issue, and potentially a reference to a tracking item. Trivial TODOs should be removed (see I.C).
        Good Examples (to retain/encourage):
            // TODO: This section is not thread-safe and needs a mutex. Currently, it can lead to data corruption under concurrent access.
            // FIXME: The current error handling here doesn't propagate critical failures, masking underlying problems. Needs to return an error.
            // TODO(username): Investigate performance degradation when input size exceeds 1MB (see #456).
    D. Documenting Exported Symbols (godoc):
        Rule: All exported package names, functions, types, and constants in Go should have a doc comment explaining their purpose and usage, following godoc conventions. The comment should start with the name of the item being documented.
        Action: Retain and ensure it follows godoc format. If missing or inadequate, prompt the developer to add or improve it. The AI should verify that the comment explains what the exported entity does and why a consumer would use it.
        Good Examples (to retain/encourage):
            // Package store provides thread-safe access to an in-memory key-value store. package store
            // NewClient creates and returns a new API client configured with the given endpoint and credentials. func NewClient(endpoint string, apiKey string) (*Client, error) { ... }
            // User represents a user in the system with an ID and Name. type User struct { ... }
    E. Explaining Non-Obvious Parameters or Return Values:
        Rule: If the purpose or meaning of function parameters or return values (especially multiple return values or interface{} types) isn't crystal clear from their names and types, a comment can clarify.
        Action: Retain. If unclear, prompt for clarification.
        Good Examples (to retain/encourage):
            // processData takes rawData and a threshold. Returns the processed items and a boolean indicating if any data was filtered. func processData(rawData []byte, threshold int) ([]ProcessedItem, bool, error) { ... }
    F. Highlighting Potential Pitfalls or Edge Cases:
        Rule: Comments that warn future developers (or the original author) about potential issues, edge cases the code handles (or doesn't handle), or important assumptions made by the code.
        Action: Retain. Ensure the warning or explanation is clear.
        Good Examples (to retain/encourage):
            // Important: This function assumes the input string is valid UTF-8. Behavior is undefined for other encodings.
            // Warning: Modifying this slice directly while iterating can lead to unexpected behavior due to Go's range loop semantics.

General AI Behavior:

    Iterative Refinement: The AI should be prepared to work with the developer iteratively. Instead of just deleting, it can suggest rephrasing or ask clarifying questions.
    Context is Key: The AI should consider the surrounding code and the module's purpose when evaluating a comment.
    Formatting: Ensure comments (especially godoc comments) follow standard Go formatting (e.g., // A Comment not //AComment).
    Learning: While not explicitly requested for this standard, ideally, the AI would learn from developer feedback to improve its suggestions over time.